# RSA

两个素数 p,q 。N = pq

如果有 e 和 d 在 $\phi(N)=(p-1)(q-1)$ 下互为逆元

那么设n为明文，解密就是 ${(n^e)}^d \equiv n^{de} \equiv 1 \mod N$



加密(N,e)，作为公钥所有人都知道。

解密(N,d)，作为私钥。



## 大数的模幂运算

虽然python 自带大数运算，但要在 a、b 很大的条件下计算 $a^b$ 还是有点不太现实。

我们要充分利用 “在模n下” 这个条件，避免某些特别大的数出现。

方法是结合常见的快速幂，$b=a^{x_0*2^0}*a^{x_1*2^1}*a^{x_2*2^2}...$ ，其中 $x_i=0或1$ 。

计算各个 $a^{2^i*x_i} \mod n$  ，然后再将它们乘起来，达到各个击破的目的。



### 生成 p 和 q

p 和 q 要求都是很大的素数，于是我们采用一个暴力的方法：先随机生成一个大数，然后判断其是否为素数，如果不是素数就重新生成。

**判断素数分为两步**：

1.筛选掉显而易见的素数

2.Miller_Rabin 素数测试



#### Miller_Rabin 素数测试

如果 p 是素数，一定满足费马小定理  $a^{p-1}\equiv 1 \mod p$ 。换言之，如果不满足费马小定理，就一定是合数。

然而这还不够，因为还有很多合数满足费马小定理。

如果  $a^{p-1}\equiv 1 \mod p$ ，那么显然 $a^{\frac{p-1}{2}}\equiv 1 \mod p$ 或  $a^{\frac{p-1}{2}}\equiv -1 \mod p$ 

设 $a^{p-1} = a^{2^q*m}$  ，检查满足 $a^m \leq a^{2^k*m} < a^{p-1}$ 的 k 的值，必然有一个满足在模p下的值为 1或-1。

我们对此进行检查，这便是 “Miller_Rabin 素数测试“ 了。

反复测试k次，它的错误概率小于等于 ${(\frac{1}{4})}^k$​





### padding

RSA算法是一个块加密算法（ block cipher algorithm），总是在一个固定长度的块上进行操作。理论上1024bits的密钥可以加密的数据最大长度为1024bits。2048bits的密钥可以加密的数据最大长度为2048bits。

分块后可能有些部分没有达到固定长度，于是填充一些东西，这可以增加RSA的安全性。



这里采用1024bits和最常用的填充模式，即RSA_PKCS1_PADDING。

```
00 02 < at least 8 random non-null-bytes > 00 < message >
<--           total length: keylength bits            -->
```

可以看出【填充的部分>=11字节】，因此加密的基本单位大小等于 (1024/8)-11 字节。





### 求模逆

原理看这个：https://www.bilibili.com/read/cv26765015/

我们最终的目标就是求出 $sa+tb \equiv 1\mod b$ 中的 s，显然它就是要求的逆元。

固定 $a=r_{j-1} $ 以及 $b=r_j$ ，求得 $q_{j+1}=[\frac{r_{j-1}}{r_j}]$

每一轮更新 ：

$s_{j+1}=s_{j-1}-s_jq_{j+1}$

 $t_{j+1}=t_{j-1}-t_jq_{j+1}$



##### 具体实现分析：

**初始** $j=-1$，此时 $a=r_{-2}$ 、 $b=r_{-1}$ 

根据定义

$s_{-2}=1 $ and  $t_{-2}=0$ 

$s_{-1}=0$ and $t_{-1}=1$



**中间某轮** 

更新a=b

$b=r_{j+1}$​

$s_{j+1}=s_{j-1}-s_jq_{j+1}$

 $t_{j+1}=t_{j-1}-t_jq_{j+1}$



**结束** 

设最初的 a、b 分别为 $a_0$ 、$b_0$

上一轮求得的 $b=r_{j+1}$ 等于0，代表 $r_{j-1}$被 $r_j$ 整除。$r_{j}$​为$gcd(a_0,b_0)$，要求逆元意味着它肯定是1。

即最后的式子为 $s_ja_0+t_jb_0=r_j$ 

这个 $s_j$​ 就是我们最后要求的“逆元”。注意可能是负数，需将它转化为模b下相应的正数。