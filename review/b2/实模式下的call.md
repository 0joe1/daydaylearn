#实模式下的 call
共 4 种方式
- 相对近调用
-  间接绝对近调用
- 直接绝对远调用
- 间接绝对远调用

数据类型伪指令 
有 byte、word、dword、qword 等,它们用在操作数前,相当于做数据类型强制转换,这和 C 语言中的数据类型转换是一个道理。在汇编语言中,无论操作数是立即数、寄存器,或是内存,都可以用数据类型伪指令。

short 表示在内存或寄存器取 1 字节；near 表示中取 2 字节；far 表示取 4 字节。


#### 相对近调用

 我们平常写的代码，比如说 call near prog_name 。near 可以省略,nasm 编译器默认在地址处取 2 字节。
标号prog_name变成数字就是从section开始的偏移， 它并不是操作数，需要经过编译器的转化。
真正的操作数是标号偏移量与当前指令的下一字节偏移量的差值。

然而，CPU不能直接把这个操作数送到 ip寄存器 。送到ip的是绝对地址，因此在实际执行中还要将此增量还原成绝对地址。所以此相对近调用并不能称为“直接”相对近调用。
恢复成绝对地址的方法是:当前的 IP 指针+操作数+机器码大小=目标函数绝对地址

举个例子
call指令长度为3，段内偏移地址为2， prog_name 等于10。
那么 真正的操作数 = 10 - 2 - 3 = 5
再假设 当前ip的值 = 7 （ip指向call指令的第一个字节）
下一步装载到 ip 的数 = 目标函数绝对地址 = 7+5+3 =15

ps：注意标号是从section开始的偏移，而非绝对地址（除非你的整个程序就只有一个section）。不然的话，编译器为什么还要费尽心思转化呢？

####  间接绝对近调用
“间接”指地址在寄存器或内存中,不以立即数的形式出现。
“绝对”指目标函数的地址是绝对地址，可以被直接装到 ip 里的那种。
“近调用”，即只能调用同一个代码段中的函数,只给出段内偏移就好。

#### 直接绝对远调用
操作数在指令中直接给出,是立即数。
指令的一般形式是:
call far 段基址(立即数):段内偏移地址(立即数)
对于直接绝对远调用,far 也可以不加，不加人家编译器也能看出来这是直接绝对远调用。
在操作数中，汇编指令中给出的顺序是相反，偏移地址在前,段基址在后。这一点要切记。

#### 间接绝对远调用
远调用意味着英雄何必仅仅拘泥在当前代码段。于是这种方式既放cs，又放ip。其中cs在高地址处，ip在低地址处。
16 位间接绝对远调用指令格式是:call far 内存寻址。在此调用方式中一定要加个关键字 far,否则就和第 2 种的间接绝对近调用一样了。


### 实模式下的 jmp
共 5 类
- 相对短转移
- 相对近转移
- 间接绝对近转移
- 直接绝对远转移
- 间接绝对远转移

jmp和call其实没多大区别，你懂得了call就懂得了jmp。你完全可以类推前面的。call跳过去后会把cs和ip压栈，jmp不会，仅此而已。

补充一个相对短转移：
指令格式是  jmp  short 立即数地址。
相对短转移中的“短”,体现在操作数中,即跳转的范围只能是 1 字节有符号数所表示的范围,即-128~127。

参考资料：
操作系统真象还原