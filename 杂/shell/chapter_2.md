### Note

1.在shell中也可以使用 printf，第一个是格式化字符串，后面的是参数。

2.cat 会将命令行上的文件的输出拼接到一起

3.`&>`和`>&`只是将STDOUT 和 STDERR 发送到相同地方的便捷写法。

当写`>&`时，后面那个是文件描述符的意思。

重定向`>`的前导数字为1

4.命令行中的管道会先于重定向进行处理，因此当写 `2&>1`的时候，bash识别出标准输入连接到了管道，并假定你希望将标准错误也连入管道。

如果再后面跟的是重定向的话，比如 `somecmd 2&>1 >my.file` ，就意味着先把 2的内容发送给1,然后1的内容被重定向给myfile(`>`前默认的文件描述符是1)。于是2仍然会被打印在屏幕上。

由于这种特性，我们无法只将标准错误传入其他命令，除非提前交换文件描述符：

5.用一个中间变量，如`./myscript 3&>1 2>&3` ，如果在 `2>&3`后面加上`-`，代表操作完成后关闭文件描述符3。

6. `tee -a`选项表述追加，而不是替换。



### Tasks

1. 分别打印  "Hello-world" 和 "Hi-you" 

​	要求字符的最大输出字符数量为8,且都是整齐的9个字符，向左对齐。

   2.拼接两个文件内容到一个新文件

3. a. 将 ls 的内容保存至lsout.txt（要求内容为一排）

​	b. 将ls 的内容以列的方式显示

4. `&>` 和 `>&` 是什么的便捷写法？

both是准备向STDERR和STDOUT生成输出的假想程序，那么`both >&2 outfile ` 是什么意思？

5. 在一行中将多个命令的正确输出和错误消息的内容重定向到a.txt，然后使用 tail 

   a.读取文件最后2行

   b.读取读取文件除了前两行之外的内容

6. 寻找根目录下以 .c 结尾的文件，将其保存之 allmyc 中的同时显示在终端上。(错误信息也要写入文件)

7. 还是上面的查找操作，但是这次你需要把标准输出写到stdout.logfile 中，把标准错误写到 stderr.logfile中，同时显示在终端上。
